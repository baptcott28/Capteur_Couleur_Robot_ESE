/*
 * color_sensor.h
 *
 *  Created on: Oct 21, 2022
 *      Author: bapti
 *
 *
 */

#ifndef SRC_COLOR_SENSOR_H_
#define SRC_COLOR_SENSOR_H_

//liste des Pin en fin de fichier


// Macro necessaires a l'abstraction de la lib HAL

#define color_S2_Pin GPIO_PIN_4
#define color_S2_GPIO_Port GPIOB
#define color_input_freq_Pin GPIO_PIN_15
#define color_input_freq_GPIO_Port GPIOA
#define button_Pin GPIO_PIN_11
#define button_GPIO_Port GPIOI
#define button_EXTI_IRQn EXTI15_10_IRQn
#define color_enable_Pin GPIO_PIN_7
#define color_enable_GPIO_Port GPIOC
#define color_S0_Pin GPIO_PIN_6
#define color_S0_GPIO_Port GPIOC
#define color_S3_Pin GPIO_PIN_7
#define color_S3_GPIO_Port GPIOG
#define color_S1_Pin GPIO_PIN_6
#define color_S1_GPIO_Port GPIOG

#define NB_MEASURE_WANTED 20 			// Mettre un nombre pair, moyennage des valeur obtenues.


// --- fonction d'abstraction de la HAL ---

typedef enum tim_mode{
	INPUT_CAPTURE_IT = 1,
	BASE_IT = 2,
	PWM = 3
}tim_mode_t;

typedef enum tim_status{
	INIT=2,
	START = 1,
	STOP = 0
}tim_status_t;

void GPIO_write(GPIO_TypeDef * gpio_port,uint16_t gpio_pin,GPIO_PinState gpio_PinState );
void timer_handle(TIM_HandleTypeDef htim, tim_mode_t mode, tim_status_t status,uint32_t channel);


// ----- Declaration of the color sensor's usefull struct fields -----

typedef enum color_sensor_color_enum{
	RED =1,
	BLUE=2,
	CLEAR=3,
	GREEN=4
}color_sensor_color_t;

typedef enum color_sensor_output_scale_enum{
	CENT_POUR_CENT=4,
	VINGT_POUR_CENT=3,
	DEUX_POUR_CENT=2,
	POWER_DOWN=1
}color_sensor_output_scale_t;

typedef enum color_sensor_state_enum{
	SENSOR_ENABLE=1,
	SENSOR_DISABLE=0
}color_sensor_state_t;

typedef enum calibration_state_enum{
	WAINTING_FOR_CALIB=0,
	CALIB_VERT_CANETTE=1,
	CALIB_VERT_VIDE=2,
	CALIB_ROUGE_CANETTE=3,
	CALIB_ROUGE_VIDE=4,
	CALIB_DONE=5
}calibration_state_t;

/**
 * \struct h_green_transormation_t
 * \brief Contain the coeficient to transfomr the green values
 */
typedef struct h_green_transormation_t{
	uint16_t green_coef_dir;
	uint16_t green_ord_origin;
	uint16_t green_max_freq;
}h_green_transformation_t;

/**
 * \struct h_red_transormation_t
 * \brief Contain the coeficient to transfomr the red values
 */
typedef struct h_red_transformation_t{
	uint16_t red_coef_dir;
	uint16_t red_ord_origin;
	uint16_t red_max_freq;
}h_red_transformation_t;

/**
 * \struct h_calibration_structure_t
 * \brief Calibration object. Contain raw values of the sensor calibration
 */
typedef struct h_calibration_struct_t{
	uint16_t calib_value_vert_canette;
	uint16_t calib_value_vert_vide;
	uint16_t calib_value_rouge_canette;
	uint16_t calib_value_rouge_vide;
}h_calib_structure_t;

typedef uint32_t color_t;


// ----- Declaration of the color sensor structure -----

/**
 * \struct h_color_sensor_t
 * \brief Color sensor object
 *
 * This object contains all the features of this color sensor. It allow user to manage more than 1 color sensor at a time and deal with them easily
 */
typedef struct h_color_sensor_t{
	color_sensor_color_t color;
	color_sensor_output_scale_t ouput_scale;
	color_sensor_state_t sensor_state;
	uint32_t frequence;
	color_t green_color;
	color_t	red_color;
	color_t blue_color;
	calibration_state_t calib_state;
	h_green_transformation_t green_transormation;
	h_red_transformation_t red_transformation;
}h_color_sensor_t;


// ----- Color sensor functions -----

void color_sensor_init(h_color_sensor_t * h_color_sensor, color_sensor_color_t color, color_sensor_output_scale_t output_scale, color_sensor_state_t state);

/**
 * @fn int color_Enable(h_color_sensor_t * h_color_sensor)
 * @brief Enable the sensor by setting to 0 the ENABLE pin
 *
 * @param h_color_sensor : color_sensor structure
 * @return 0 if failed else 1
 */
void color_enable(h_color_sensor_t * h_color_sensor);

/**
 * @fn int color_Disable(h_color_sensor_t * h_color_sensor)
 * @brief disable the sensor by setting to 1 the ENABLE pin
 *
 * @param h_color_sensor : color_sensor structure
 * @return 0 if failed else 1
 */
void color_disable(h_color_sensor_t * h_color_sensor);
void color_sensor_handle_input_capture_IT(h_color_sensor_t * h_color_sensor, TIM_TypeDef* TIM);
int color_handle_raw_values(h_color_sensor_t * h_color_sensor, uint32_t frequence);
uint32_t color_handle_calibration_sensor(h_color_sensor_t * h_color_sensor, uint32_t frequence,h_calib_structure_t * h_calib_struct);
void color_calibrate_sensor(h_color_sensor_t * h_color_sensor);
uint32_t color_getGreenValue(h_color_sensor_t * h_color_sensor);
uint32_t color_getRedValue(h_color_sensor_t * h_color_sensor);
uint16_t measure_calibration_value(h_color_sensor_t * h_color_sensor, uint32_t frequence,h_calib_structure_t * h_calib_struct);



/*  liste des Pins
 *		color_S0	GPIO_output
 *	    color_S1	GPIO_output
 *		color_S2	GPIO_output
 *		color_S3	GPIO_output
 *		color_enable GPIO_Output
 *		3,3V ou 5V (*2)
 *		GND
 *		color_freq	INPUT_CAPTURE
 *
 *		1 timer en input capture
 *	    Voir si un timer est dispo pour déclencher tout les demi secondes le changelnt de filtre ou alors 4 cycle de IC et on passe au filtre suivant : je gererai ça une fois en programation
 */

#endif /* SRC_COLOR_SENSOR_H_ */
